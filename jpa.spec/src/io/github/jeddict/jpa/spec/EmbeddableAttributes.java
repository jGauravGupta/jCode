//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2014.01.21 at 01:52:19 PM IST
//
package io.github.jeddict.jpa.spec;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;
import org.eclipse.persistence.internal.jpa.metadata.accessors.classes.XMLAttributes;
import static io.github.jeddict.jcode.jpa.JPAConstants.BASIC_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.ELEMENT_COLLECTION_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.EMBEDDED_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.MANY_TO_MANY_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.MANY_TO_ONE_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.ONE_TO_MANY_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.ONE_TO_ONE_FQN;
import static io.github.jeddict.jcode.jpa.JPAConstants.TRANSIENT_FQN;
import io.github.jeddict.jpa.spec.extend.Attribute;
import io.github.jeddict.jpa.spec.extend.PersistenceAttributes;
import io.github.jeddict.jpa.spec.workspace.WorkSpace;
import io.github.jeddict.source.JavaSourceParserUtil;
import static io.github.jeddict.source.JavaSourceParserUtil.getElements;

/**
 * <p>
 * Java class for embeddable-attributes complex type.
 *
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * <pre>
 * &lt;complexType name="embeddable-attributes">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="basic" type="{http://java.sun.com/xml/ns/persistence/orm}basic" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="many-to-one" type="{http://java.sun.com/xml/ns/persistence/orm}many-to-one" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="one-to-many" type="{http://java.sun.com/xml/ns/persistence/orm}one-to-many" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="one-to-one" type="{http://java.sun.com/xml/ns/persistence/orm}one-to-one" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="many-to-many" type="{http://java.sun.com/xml/ns/persistence/orm}many-to-many" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="element-collection" type="{http://java.sun.com/xml/ns/persistence/orm}element-collection" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="embedded" type="{http://java.sun.com/xml/ns/persistence/orm}embedded" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="transient" type="{http://java.sun.com/xml/ns/persistence/orm}transient" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 *
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "embeddable-attributes", propOrder = {})
public class EmbeddableAttributes extends PersistenceAttributes<Embeddable> {

    @Override
    public void load(EntityMappings entityMappings, TypeElement typeElement, boolean fieldAccess) {
        List<Element> elements = getElements(typeElement, fieldAccess);

        for (Element element : elements) {
            VariableElement variableElement;
            ExecutableElement getterElement;
            if (element instanceof VariableElement) {
                variableElement = (VariableElement) element;
                getterElement = JavaSourceParserUtil.guessGetter(variableElement);
            } else {
                variableElement = JavaSourceParserUtil.guessField((ExecutableElement) element);
                getterElement = (ExecutableElement) element;
            }

            if (JavaSourceParserUtil.isAnnotatedWith(element, BASIC_FQN)) {
                this.addBasic(Basic.load(element, variableElement, getterElement));
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, TRANSIENT_FQN)) {
                this.addTransient(Transient.load(element, variableElement, getterElement));
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, ELEMENT_COLLECTION_FQN)) {
                this.addElementCollection(ElementCollection.load(entityMappings, element, variableElement, getterElement));
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, ONE_TO_ONE_FQN)) {
                OneToOne oneToOneObj = new OneToOne();
                this.addOneToOne(oneToOneObj);
                oneToOneObj.load(entityMappings, element, variableElement, getterElement, null);
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, MANY_TO_ONE_FQN)) {
                ManyToOne manyToOneObj = new ManyToOne();
                this.addManyToOne(manyToOneObj);
                manyToOneObj.load(entityMappings, element, variableElement, getterElement, null);
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, ONE_TO_MANY_FQN)) {
                OneToMany oneToManyObj = new OneToMany();
                this.addOneToMany(oneToManyObj);
                oneToManyObj.load(entityMappings, element, variableElement, getterElement, null);
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, MANY_TO_MANY_FQN)) {
                ManyToMany manyToManyObj = new ManyToMany();
                this.addManyToMany(manyToManyObj);
                manyToManyObj.load(entityMappings, element, variableElement, getterElement, null);
            } else if (JavaSourceParserUtil.isAnnotatedWith(element, EMBEDDED_FQN)) {
                this.addEmbedded(Embedded.load(entityMappings, element, variableElement, getterElement));
            } else {
                this.addBasic(Basic.load(element, variableElement, getterElement)); //Default Annotation
            }
        }

    }

    @Override
    public XMLAttributes getAccessor(WorkSpace workSpace) {
        XMLAttributes attr = super.getAccessor(workSpace);
        attr.setIds(new ArrayList<>());
        attr.setVersions(new ArrayList<>());
        return updateAccessor(workSpace, attr);
    }

    @Override
    public XMLAttributes getAccessor(WorkSpace workSpace, boolean inherit) {//inherit not supported
        XMLAttributes attr = super.getAccessor(workSpace);
        return attr;
    }

    public XMLAttributes updateAccessor(WorkSpace workSpace, XMLAttributes attr) {
        super.updateAccessor(workSpace, attr, false);
        return attr;
    }

    public static List<String> getPaths(String prefix, Embedded embedded, Predicate<Attribute> filter) {
        final String leafPrefix = prefix.isEmpty() ? embedded.getName() : (prefix + '.' + embedded.getName());
        List<Attribute> attributes = embedded.getConnectedClass().getAttributes().getAllAttribute(true);
        List<String> paths = attributes.stream()
                .filter(attr -> attr instanceof Embedded)
                .map(attr -> (Embedded) attr)
                .map(emb -> getPaths(leafPrefix, emb, filter))
                .collect(ArrayList<String>::new, ArrayList::addAll, ArrayList::addAll);
        paths.addAll(attributes.stream()
                .filter(filter)
                .map(Attribute::getName)
                .map(leaf -> leafPrefix + '.' + leaf)
                .collect(ArrayList<String>::new, ArrayList::add, ArrayList::addAll));
        return paths;
    }

}
