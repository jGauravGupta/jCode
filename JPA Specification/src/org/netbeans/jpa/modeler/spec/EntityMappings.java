//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2014.01.21 at 01:52:19 PM IST
//
package org.netbeans.jpa.modeler.spec;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import static java.util.stream.Collectors.toList;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.commons.lang.StringUtils;
import org.netbeans.jcode.core.util.JavaSourceHelper;
import org.netbeans.jpa.modeler.spec.design.Diagram;
import org.netbeans.jpa.modeler.spec.design.Plane;
import org.netbeans.jpa.modeler.spec.extend.Attribute;
import org.netbeans.jpa.modeler.spec.extend.BaseElement;
import org.netbeans.jpa.modeler.spec.extend.JavaClass;
import org.netbeans.jpa.modeler.spec.extend.MapKeyHandler;
import org.netbeans.jpa.modeler.spec.extend.MultiRelationAttribute;
import org.netbeans.jpa.modeler.spec.extend.RelationAttribute;
import org.netbeans.jpa.modeler.spec.extend.Snippet;
import org.netbeans.jpa.modeler.spec.extend.SnippetLocationType;
import org.netbeans.modeler.specification.version.SoftwareVersion;
import org.netbeans.jpa.modeler.spec.extend.cache.Cache;
import org.netbeans.modeler.core.NBModelerUtil;
import org.netbeans.modeler.core.exception.InvalidElmentException;
import org.netbeans.modeler.specification.model.document.IDefinitionElement;
import org.netbeans.modeler.specification.model.document.IRootElement;
import org.netbeans.modeler.specification.model.document.core.IBaseElement;
import org.openide.windows.InputOutput;

/**
 *
 *
 * The entity-mappings element is the root element of a mapping file. It
 * contains the following four types of elements:
 *
 * 1. The persistence-unit-metadata element contains metadata for the entire
 * persistence unit. It is undefined if this element occurs in multiple mapping
 * files within the same persistence unit.
 *
 * 2. The package, schema, catalog and access elements apply to all of the
 * entity, mapped-superclass and embeddable elements defined in the same file in
 * which they occur.
 *
 * 3. The sequence-generator, table-generator, converter, named-query,
 * named-native-query, named-stored-procedure-query, and sql-result-set-mapping
 * elements are global to the persistence unit. It is undefined to have more
 * than one sequence-generator or table-generator of the same name in the same
 * or different mapping files in a persistence unit. It is undefined to have
 * more than one named-query, named-native-query, sql-result-set-mapping, or
 * named-stored-procedure-query of the same name in the same or different
 * mapping files in a persistence unit. It is also undefined to have more than
 * one converter for the same target type in the same or different mapping files
 * in a persistence unit.
 *
 * 4. The entity, mapped-superclass and embeddable elements each define the
 * mapping information for a managed persistent class. The mapping information
 * contained in these elements may be complete or it may be partial.
 *
 *
 *
 * <p>
 * Java class for anonymous complex type.
 *
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="description" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="persistence-unit-metadata" type="{http://java.sun.com/xml/ns/persistence/orm}persistence-unit-metadata" minOccurs="0"/>
 *         &lt;element name="package" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="schema" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="catalog" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="access" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}access-type" minOccurs="0"/>
 *         &lt;element name="sequence-generator" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}sequence-generator" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="table-generator" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}table-generator" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-native-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-native-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-stored-procedure-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-stored-procedure-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="sql-result-set-mapping" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}sql-result-set-mapping" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="mapped-superclass" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}mapped-superclass" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="entity" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}entity" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="embeddable" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}embeddable" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="converter" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}converter" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *       &lt;attribute name="version" use="required" type="{http://java.sun.com/xml/ns/persistence/orm}versionType" fixed="2.0" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 *
 */
@XmlType(name = "entity-mappings", propOrder = {
    "description",
    "persistenceUnitMetadata",
    "_package_dep",
    "schema",
    "catalog",
    "access",
    "sequenceGenerator",
    "tableGenerator",
    "namedQuery",
    "namedNativeQuery",
    "namedStoredProcedureQuery",
    "sqlResultSetMapping",
    "mappedSuperclass",
    "entity",
    "embeddable",
    "converter",
    "snippets",
    "cache",
    "jpaDiagram"
})
@XmlRootElement(name = "entity-mappings")
@XmlAccessorType(XmlAccessType.FIELD)
public class EntityMappings extends BaseElement implements IDefinitionElement, IRootElement {

    private static final String DEFAULT_PU_NAME = "DEFAULT_PU";

    protected String description;
    @XmlElement(name = "persistence-unit-metadata")
    protected PersistenceUnitMetadata persistenceUnitMetadata;
    @XmlAttribute(name = "pkg")
    protected String _package;
    @XmlElement(name = "package")
    protected String _package_dep;//Compatibility support
    protected String schema;
    protected String catalog;
    protected AccessType access;
    @XmlElement(name = "sequence-generator")
    protected List<SequenceGenerator> sequenceGenerator;
    @XmlElement(name = "table-generator")
    protected List<TableGenerator> tableGenerator;
    @XmlElement(name = "nq")//(name = "named-query")
    protected List<NamedQuery> namedQuery;
    @XmlElement(name = "nnq")//(name = "named-native-query")
    protected List<NamedNativeQuery> namedNativeQuery;
    @XmlElement(name = "nspq")//(name = "named-stored-procedure-query")
    protected List<NamedStoredProcedureQuery> namedStoredProcedureQuery; //REVENG PENDING
    @XmlElement(name = "srsm")//(name = "sql-result-set-mapping")
    protected Set<SqlResultSetMapping> sqlResultSetMapping;

//    @XmlElement(name = "default-class")
    @XmlTransient
    private List<DefaultClass> defaultClass;
    @XmlElement(name = "mapped-superclass")
    protected List<MappedSuperclass> mappedSuperclass;
    protected List<Entity> entity;
    protected List<Embeddable> embeddable;
    protected List<Converter> converter;//REVENG PENDING
    @XmlAttribute(name = "v", required = true)
    protected String version;
    @XmlTransient
    private SoftwareVersion previousVersion;
    @XmlAttribute(name = "dv")
    private String diagramVersion;
    @XmlElement(name = "diagram")
    private Diagram jpaDiagram;//Custom Added
    @XmlAttribute
    private String status;//GENERATED (DBRE,JCRE)
    @XmlAttribute(name = "thm")
    private String theme;
    @XmlAttribute(name = "dbthm")
    private String dbTheme;
    @XmlAttribute
    private String persistenceUnitName;

    @XmlElement(name = "c")
    private Cache cache;
    @XmlAttribute(name = "sm")
    private Boolean generateStaticMetamodel = false;
    @XmlAttribute(name = "smpkg")
    private String staticMetamodelPackage;

    /**
     * JAXB Attributes Start *
     */
    @XmlAttribute(name = "xs")
    private Boolean jaxbSupport = false;
    @XmlAttribute(name = "xn")
    private String jaxbNameSpace;

    /**
     * JAXB Attributes End *
     */
    
    @XmlElement(name = "snp")
    private List<Snippet> snippets;
    private static final Snippet DEAFULT;

    static {
        DEAFULT = new Snippet();
        DEAFULT.setValue("/**\n" +
                        " * This file was generated by the JPA Modeler\n" +
                        " */");
        DEAFULT.setLocationType(SnippetLocationType.BEFORE_PACKAGE);
    }
    
    private EntityMappings() {
    }

    public void initJavaInheritenceMapping() {
        List<JavaClass> javaClassList = this.getJavaClass();
        javaClassList.stream().filter((javaClass) -> (javaClass.getSuperclassId() != null)).forEach((javaClass) -> {
            JavaClass javaSuperclass = getJavaClass(javaClass.getSuperclassId());
            javaClass.addSuperclass(javaSuperclass);
        });
    }

    //UPDATE ELEMENT
    public boolean isClassExist(String _class) {
        if (mappedSuperclass != null) {
            if (mappedSuperclass.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (entity != null) {
            if (entity.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (embeddable != null) {
            if (embeddable.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Gets the value of the description property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * Gets the value of the persistenceUnitMetadata property.
     *
     * @return possible object is {@link PersistenceUnitMetadata }
     *
     */
    public PersistenceUnitMetadata getPersistenceUnitMetadata() {
        return persistenceUnitMetadata;
    }

    /**
     * Sets the value of the persistenceUnitMetadata property.
     *
     * @param value allowed object is {@link PersistenceUnitMetadata }
     *
     */
    public void setPersistenceUnitMetadata(PersistenceUnitMetadata value) {
        this.persistenceUnitMetadata = value;
    }

    /**
     * Gets the value of the package property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getPackage() {
        if(StringUtils.isBlank(_package)){
            return null;
        }
        return _package;
    }

    /**
     * Sets the value of the package property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setPackage(String value) {
        this._package = value;
    }

    /**
     * Gets the value of the schema property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Sets the value of the schema property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setSchema(String value) {
        this.schema = value;
    }

    /**
     * Gets the value of the catalog property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Sets the value of the catalog property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setCatalog(String value) {
        this.catalog = value;
    }

    /**
     * Gets the value of the access property.
     *
     * @return possible object is {@link AccessType }
     *
     */
    public AccessType getAccess() {
        return access;
    }

    /**
     * Sets the value of the access property.
     *
     * @param value allowed object is {@link AccessType }
     *
     */
    public void setAccess(AccessType value) {
        this.access = value;
    }

    /**
     * Gets the value of the sequenceGenerator property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the sequenceGenerator property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSequenceGenerator().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SequenceGenerator }
     *
     *
     */
    public List<SequenceGenerator> getSequenceGenerator() {
        if (sequenceGenerator == null) {
            sequenceGenerator = new ArrayList<SequenceGenerator>();
        }
        return this.sequenceGenerator;
    }

    /**
     * Gets the value of the tableGenerator property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the tableGenerator property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTableGenerator().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TableGenerator }
     *
     *
     */
    public List<TableGenerator> getTableGenerator() {
        if (tableGenerator == null) {
            tableGenerator = new ArrayList<TableGenerator>();
        }
        return this.tableGenerator;
    }

    /**
     * Gets the value of the namedQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedQuery }
     *
     *
     */
    public List<NamedQuery> getNamedQuery() {
        if (namedQuery == null) {
            namedQuery = new ArrayList<NamedQuery>();
        }
        return this.namedQuery;
    }

    /**
     * Gets the value of the namedNativeQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedNativeQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedNativeQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedNativeQuery }
     *
     *
     */
    public List<NamedNativeQuery> getNamedNativeQuery() {
        if (namedNativeQuery == null) {
            namedNativeQuery = new ArrayList<NamedNativeQuery>();
        }
        return this.namedNativeQuery;
    }

    /**
     * Gets the value of the namedStoredProcedureQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedStoredProcedureQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedStoredProcedureQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedStoredProcedureQuery }
     *
     *
     */
    public List<NamedStoredProcedureQuery> getNamedStoredProcedureQuery() {
        if (namedStoredProcedureQuery == null) {
            namedStoredProcedureQuery = new ArrayList<NamedStoredProcedureQuery>();
        }
        return this.namedStoredProcedureQuery;
    }

    /**
     * Gets the value of the sqlResultSetMapping property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the sqlResultSetMapping property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSqlResultSetMapping().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SqlResultSetMapping }
     *
     *
     */
    public Set<SqlResultSetMapping> getSqlResultSetMapping() {
        if (sqlResultSetMapping == null) {
            sqlResultSetMapping = new HashSet<SqlResultSetMapping>();
        }
        return this.sqlResultSetMapping;
    }

    /**
     * Gets the value of the mappedSuperclass property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the mappedSuperclass property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMappedSuperclass().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MappedSuperclass }
     *
     *
     */
    public List<MappedSuperclass> getMappedSuperclass() {
        if (mappedSuperclass == null) {
            mappedSuperclass = new ArrayList<MappedSuperclass>();
        }
        return this.mappedSuperclass;
    }

    public MappedSuperclass getMappedSuperclass(String id) {
        if (mappedSuperclass != null) {
            for (MappedSuperclass mappedSuperclass_In : mappedSuperclass) {
                if (id.equals(mappedSuperclass_In.getId())) {
                    return mappedSuperclass_In;
                }
            }
        }
        return null;
    }

    /**
     * Gets the value of the entity property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the entity property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEntity().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list {@link Entity }
     *
     *
     */
    public List<Entity> getEntity() {
        if (entity == null) {
            entity = new ArrayList<>();
        }
        return this.entity;
    }

    public void setEntity(List<Entity> entity) {
        if (this.entity == null) {
            this.entity = new ArrayList<>();
        }
        this.entity = entity;
    }

    /**
     * Gets the value of the embeddable property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the embeddable property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbeddable().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Embeddable }
     *
     *
     */
    public List<Embeddable> getEmbeddable() {
        if (embeddable == null) {
            embeddable = new ArrayList<Embeddable>();
        }
        return this.embeddable;
    }

    /**
     * Gets the value of the converter property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the converter property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConverter().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Converter }
     *
     *
     */
    public List<Converter> getConverter() {
        if (converter == null) {
            converter = new ArrayList<Converter>();
        }
        return this.converter;
    }

    /**
     * Gets the value of the version property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getVersion() {
        if(StringUtils.isBlank(version)){
            version = "0.0";
        }
        return version;
    }

    /**
     * Sets the value of the version property.
     *
     * @param value allowed object is {@link float }
     *
     */
    public void setVersion(String value) {
        this.version = value;
    }
    
    public void setVersion(SoftwareVersion value) {
        this.version = value.getValue();
    }

    @Override
    public void removeBaseElement(IBaseElement baseElement_In) {
        if (baseElement_In instanceof Entity) {
            this.removeEntity((Entity) baseElement_In);
        } else if (baseElement_In instanceof MappedSuperclass) {
            this.removeMappedSuperclass((MappedSuperclass) baseElement_In);
        } else if (baseElement_In instanceof Embeddable) {
            this.removeEmbeddable((Embeddable) baseElement_In);
        } else {
            throw new InvalidElmentException("Invalid JPA Element");
        }
    }

    @Override
    public void addBaseElement(IBaseElement baseElement_In) {
        if (baseElement_In instanceof Entity) {
            this.addEntity((Entity) baseElement_In);
        } else if (baseElement_In instanceof MappedSuperclass) {
            this.addMappedSuperclass((MappedSuperclass) baseElement_In);
        } else if (baseElement_In instanceof Embeddable) {
            this.addEmbeddable((Embeddable) baseElement_In);
        } else {
            throw new InvalidElmentException("Invalid JPA Element");
        }

    }

    public void removeEntity(Entity entity_In) {
        if (entity != null) {
            this.entity.remove(entity_In);
            entity_In.setRootElement(null);
        }
    }

    public void addEntity(Entity entity_In) {
        if (entity == null) {
            entity = new ArrayList<>();
        }
        this.entity.add(entity_In);
        entity_In.setRootElement(this);
    }

    public Entity findEntity(String entityName) {
        if(StringUtils.isBlank(entityName)){
            return null;
        }
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (entityName.equals(entity_In.getClazz())) {
                    return entity_In;
                }
            }
        }
        return null;
    }

    public IdentifiableClass findIdentifiableClass(String className) {
        if(StringUtils.isBlank(className)){
            return null;
        }
        Entity entity = findEntity(className);
        if (entity == null) {
            return findMappedSuperclass(className);
        } else {
            return entity;
        }
    }

    public Entity getEntity(String id) {
        if(StringUtils.isBlank(id)){
            return null;
        }
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (id.equals(entity_In.getId())) {
                    return entity_In;
                }
            }
        }
        return null;
    }

    public Embeddable getEmbeddable(String id) {
        if(StringUtils.isBlank(id)){
            return null;
        }
        if (embeddable != null) {
            for (Embeddable embeddable_In : embeddable) {
                if (id.equals(embeddable_In.getId())) {
                    return embeddable_In;
                }
            }
        }
        return null;
    }

    public List<Entity> findAllEntity(String entityName) {
        if(StringUtils.isBlank(entityName)){
            return null;
        }
        List<Entity> entities = new ArrayList<Entity>();
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (entityName.equals(entity_In.getClazz())) {
                    entities.add(entity_In);
                }
            }
        }
        return entities;
    }

    public void removeMappedSuperclass(MappedSuperclass mappedSuperclass_In) {
        if (mappedSuperclass != null) {
            this.mappedSuperclass.remove(mappedSuperclass_In);
            mappedSuperclass_In.setRootElement(null);
        }
    }

    public void addMappedSuperclass(MappedSuperclass mappedSuperclass_In) {
        if (mappedSuperclass == null) {
            mappedSuperclass = new ArrayList<>();
        }
        this.mappedSuperclass.add(mappedSuperclass_In);
        mappedSuperclass_In.setRootElement(this);
    }

    public MappedSuperclass findMappedSuperclass(String mappedSuperclassName) {
        if(StringUtils.isBlank(mappedSuperclassName)){
            return null;
        }
        if (mappedSuperclass != null) {
            for (MappedSuperclass mappedSuperclass_In : mappedSuperclass) {
                if (mappedSuperclassName.equals(mappedSuperclass_In.getClazz())) {
                    return mappedSuperclass_In;
                }
            }
        }
        return null;
    }

    public void removeEmbeddable(Embeddable embeddable_In) {
        if (embeddable != null) {
            this.embeddable.remove(embeddable_In);
            embeddable_In.setRootElement(null);
        }
    }

    public void addEmbeddable(Embeddable embeddable_In) {
        if (embeddable == null) {
            embeddable = new ArrayList<Embeddable>();
        }
        this.embeddable.add(embeddable_In);
        embeddable_In.setRootElement(this);
    }

    public Embeddable findEmbeddable(String embeddableName) {
        if(StringUtils.isBlank(embeddableName)){
            return null;
        }
        if (embeddable != null) {
            for (Embeddable embeddable_In : embeddable) {
                if (embeddableName.equals(embeddable_In.getClazz())) {
                    return embeddable_In;
                }
            }
        }
        return null;
    }

    /**
     * @return the jpaDiagram
     */
    public Diagram getJPADiagram() {
        return jpaDiagram;
    }

    /**
     * @param jpaDiagram the jpaDiagram to set
     */
    public void setJPADiagram(Diagram jpaDiagram) {
        this.jpaDiagram = jpaDiagram;
    }

    /**
     * @return the persistenceUnitName
     */
    public String getPersistenceUnitName() {
        if(persistenceUnitName==null){
            return DEFAULT_PU_NAME;
        }
        return persistenceUnitName;
    }

    /**
     * @param persistenceUnitName the persistenceUnitName to set
     */
    public void setPersistenceUnitName(String persistenceUnitName) {
        this.persistenceUnitName = persistenceUnitName;
    }

    /**
     * @return the defaultClass
     */
    public List<DefaultClass> getDefaultClass() {
        if (this.defaultClass == null) {
            this.defaultClass = new ArrayList<DefaultClass>();
        }
        return defaultClass;
    }

    public DefaultClass addDefaultClass(String _class) {
        if (StringUtils.isBlank(_class)) {
            throw new IllegalStateException("Class name can't empty");
        }
        if (this.defaultClass == null) {
            this.defaultClass = new ArrayList<DefaultClass>();
        }
        DefaultClass existDefaultClass = findDefaultClass(_class);

        if (existDefaultClass == null) {
            existDefaultClass = new DefaultClass(_class);
            existDefaultClass.setId(NBModelerUtil.getAutoGeneratedStringId());
            this.defaultClass.add(existDefaultClass);
            existDefaultClass.setRootElement(this);
        }
        return existDefaultClass;

    }

    public DefaultClass findDefaultClass(String _class) {
        if (this.defaultClass != null) {
            for (DefaultClass defaultClass_TMP : defaultClass) {
                if (defaultClass_TMP.getClazz().equals(_class)) {
                    return defaultClass_TMP;
                }
            }
        }
        return null;
    }

    /**
     * @return the status
     */
    public String getStatus() {
        return status;
    }

    /**
     * @param status the status to set
     */
    public void setStatus(String status) {
        this.status = status;
    }

    public void setGenerated() {
        this.status = "GENERATED";
    }

    public boolean isGenerated() {
        if ("GENERATED".equals(this.status)) {
            return true;
        } else {
            return false;
        }
    }

    public List<IdentifiableClass> getIdentifiableClass() {
        List<IdentifiableClass> identifiableClasses = new ArrayList<>(getEntity());
        identifiableClasses.addAll(getMappedSuperclass());
        return identifiableClasses;
    }

//    public void manageJoinColumnRefName() {
//        BiConsumer<Entity, List<JoinColumn>> operateRefName = (Entity entity, List<JoinColumn> joinColumns) -> {
//            joinColumns.stream().filter(c -> StringUtils.isNotBlank(c.getReferencedColumnName())).forEach(column -> {
//                Optional<Id> idOptional = entity.getAttributes().getId().stream().filter(id -> column.getReferencedColumnName().equals(id.getReferenceColumnName())).findAny();
//                if (idOptional.isPresent()) {
//                    column.setReferencedColumn(idOptional.get());//TODO Embedded ID
//                }
//            });
//        };
//        EntityMappings entityMappingsSpec = this;
//        for (IdentifiableClass identifiableClass : entityMappingsSpec.getIdentifiableClass()) {
//            for (RelationAttribute attribute : new ArrayList<>(identifiableClass.getAttributes().getRelationAttributes())) {
//                if (attribute instanceof JoinColumnHandler) {
//                    operateRefName.accept(entityMappingsSpec.findEntity(attribute.getTargetEntity()), ((JoinColumnHandler) attribute).getJoinColumn());
//                }
//                if (attribute.getJoinTable() != null) {
//                    operateRefName.accept(entityMappingsSpec.findEntity(attribute.getTargetEntity()), attribute.getJoinTable().getJoinColumn());
//                    operateRefName.accept(entityMappingsSpec.findEntity(attribute.getTargetEntity()), attribute.getJoinTable().getInverseJoinColumn());
//                }
//            }
//        }
//    }

    public void manageRefId() {
        EntityMappings entityMappingsSpec = this;

        getNamedStoredProcedureQuery().forEach(q -> manageStoredProcedureQuery(q));
        
        List<ManagedClass> classes = new ArrayList<>(entityMappingsSpec.getEntity());
        // manageSiblingAttribute for MappedSuperClass and Embeddable is not required for (DBRE) DB REV ENG CASE
        classes.addAll(entityMappingsSpec.getMappedSuperclass());
        classes.addAll(entityMappingsSpec.getEmbeddable());

        for (ManagedClass managedClass : classes) {
            
            if(managedClass instanceof Entity){
                ((Entity)managedClass).getNamedStoredProcedureQuery().forEach(q -> manageStoredProcedureQuery(q));
            }
            
            for (ManyToMany manyToMany : new ArrayList<>(managedClass.getAttributes().getManyToMany())) {
                if (manyToMany.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, manyToMany);
                    manageMapKeyAttribute(managedClass, manyToMany);
                }
            }
            for (OneToMany oneToMany : new ArrayList<>(managedClass.getAttributes().getOneToMany())) {
                if (oneToMany.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, oneToMany);
                    manageMapKeyAttribute(managedClass, oneToMany);
                }
            }
            for (ManyToOne manyToOne : new ArrayList<>(managedClass.getAttributes().getManyToOne())) {
                manageSiblingAttribute(managedClass, manyToOne);
            }
            for (OneToOne oneToOne : new ArrayList<>(managedClass.getAttributes().getOneToOne())) {
                if (oneToOne.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, oneToOne);
                }
            }
            
            for (ElementCollection elementCollection : new ArrayList<>(managedClass.getAttributes().getElementCollection())) {
                if (elementCollection.getMapKeyAttributeType()!= null) {
                    manageMapKeyAttribute(managedClass, elementCollection);
                }
            }

            // If Include Referenced Classed Checkbox is Uncheked then remove attribute
            for (RelationAttribute relationAttribute : new ArrayList<>(managedClass.getAttributes().getRelationAttributes())) {
                org.netbeans.jpa.modeler.spec.Entity targetEntity = entityMappingsSpec.findEntity(relationAttribute.getTargetEntity());
                if (targetEntity == null) {
                    managedClass.getAttributes().removeRelationAttribute(relationAttribute);
                }
            }

        }

    }

    private void manageStoredProcedureQuery(NamedStoredProcedureQuery storedProcedureQuery) {
        for(String _class : new CopyOnWriteArrayList<>(storedProcedureQuery.getResultClass())){
           String uqClass = JavaSourceHelper.getSimpleClassName(_class);
           Entity targetEntity = this.findEntity(uqClass);
           if (targetEntity != null) {
               storedProcedureQuery.getResultClass().remove(_class);
               storedProcedureQuery.addResultClass(targetEntity);
           }
        }
        
    }
    
    private void manageMapKeyAttribute(ManagedClass managedClass , MapKeyHandler mapKeyHandler) {
        if(mapKeyHandler.getMapKeyAttributeType()==null){
            return;
        }
        loadMapKeyAttribute(managedClass, mapKeyHandler);
        mapKeyHandler.setMapKeyType(mapKeyHandler.getValidatedMapKeyType());
    }
    private void loadMapKeyAttribute(ManagedClass managedClass , MapKeyHandler mapKeyHandler) {
        //Search in Entity
        org.netbeans.jpa.modeler.spec.Entity entity = this.findEntity(mapKeyHandler.getMapKeyAttributeType());
        if (entity != null) {
            mapKeyHandler.setMapKeyEntity(entity);
            return;
        }
        
        //Search in Embeddable
        Embeddable embeddable = this.findEmbeddable(mapKeyHandler.getMapKeyAttributeType());
        if (embeddable != null) { 
            mapKeyHandler.setMapKeyEmbeddable(embeddable);
            return;
        }
        
        //find Existing Attribute in current and connected class based on the instance
        if (mapKeyHandler.getMapKey() != null && StringUtils.isNotBlank(mapKeyHandler.getMapKey().getName())) {
            ManagedClass attributeContainerClass = null;
            if (mapKeyHandler instanceof ElementCollection) {
                attributeContainerClass = managedClass;
            } else if (mapKeyHandler instanceof MultiRelationAttribute) {
                MultiRelationAttribute multiRelationAttribute = (MultiRelationAttribute) mapKeyHandler;
                attributeContainerClass = multiRelationAttribute.getConnectedEntity();
            }
            if (attributeContainerClass != null) {
                List<Attribute> attributes = attributeContainerClass.getAttributes().findAllAttribute(mapKeyHandler.getMapKey().getName());
                if (attributes != null && !attributes.isEmpty()) {
                    mapKeyHandler.setMapKeyAttribute(attributes.get(0));
                }
            }
        }
    }
    // Issue Fix #5949 Start
    private void manageSiblingAttribute(JavaClass sourceJavaClass, RelationAttribute relationAttribute_Owner) {
        org.netbeans.jpa.modeler.spec.Entity targetEntity = this.findEntity(relationAttribute_Owner.getTargetEntity());
        if (targetEntity != null) {
            if (relationAttribute_Owner instanceof ManyToMany) {
                ManyToMany sourceAttribute = (ManyToMany) relationAttribute_Owner;
                ManyToMany targetAttribute = null;
                for (ManyToMany targetManyToMany : targetEntity.getAttributes().getManyToMany()) {
                    if (sourceAttribute.getName().equals(targetManyToMany.getMappedBy()) && sourceJavaClass.getClazz().equals(targetManyToMany.getTargetEntity())) {
                        targetAttribute = targetManyToMany;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);
            } else if (relationAttribute_Owner instanceof OneToMany) {
                OneToMany sourceAttribute = (OneToMany) relationAttribute_Owner;
                sourceAttribute.setConnectedEntity(targetEntity);
            } else if (relationAttribute_Owner instanceof ManyToOne) {
                ManyToOne sourceAttribute = (ManyToOne) relationAttribute_Owner;
                OneToMany targetAttribute = null;
                for (OneToMany targetOneToMany : targetEntity.getAttributes().getOneToMany()) {
                    if (sourceAttribute.getName().equals(targetOneToMany.getMappedBy()) && sourceJavaClass.getClazz().equals(targetOneToMany.getTargetEntity())) {
                        targetAttribute = targetOneToMany;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);

            } else if (relationAttribute_Owner instanceof OneToOne) {
                OneToOne sourceAttribute = (OneToOne) relationAttribute_Owner;
                OneToOne targetAttribute = null;
                for (OneToOne targetOneToOne : targetEntity.getAttributes().getOneToOne()) {
                    if (sourceAttribute.getName().equals(targetOneToOne.getMappedBy()) && sourceJavaClass.getClazz().equals(targetOneToOne.getTargetEntity())) {
                        targetAttribute = targetOneToOne;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);

            }
        }
    }
//
//    public void repairDefinition(boolean manageSiblingAttribute) {
//        repairDefinition(null, manageSiblingAttribute);
//    }

    public void repairDefinition(InputOutput IO) {
        repairDefinition(IO, false);
    }

    /**
     * Helps in compatibility support, helps to repair wrong jpa relation in JCRE
     * @param IO
     * @param manageSiblingAttribute 
     */
    public void repairDefinition(InputOutput IO, boolean manageSiblingAttribute) {

        for (ManagedClass managedClass : this.getAllManagedClass()) {
            for (RelationAttribute attribute : managedClass.getAttributes().getRelationAttributes()) {
                //if no connected-entity-id exist
                if(attribute.getConnectedEntity()==null){
                    if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append("]: ");
                            message.append("No connected entity reference found, so removing attribute").append('\n');
                            IO.getErr().print(message.toString());
                        }
                    if (attribute.getConnectedAttribute() != null) {
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Also removing connected attribute").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        //remove the connected attribute from its owning class
                        ((ManagedClass)attribute.getConnectedAttribute().getJavaClass()).getAttributes().removeRelationAttribute(attribute.getConnectedAttribute());
                    }
                    //remove to self from owning class
                    managedClass.getAttributes().removeRelationAttribute(attribute);
                    continue;
                }
                //if own is missing/found form both side
                if (attribute.getConnectedAttribute() != null) {
                    if (attribute.isOwner() && attribute.getConnectedAttribute().isOwner()) {//if both true
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Both are owner so automatic removing owner role from ").append(attribute.getConnectedAttribute().getName()).append(" (converting to mappedBy)").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.getConnectedAttribute().setOwner(false);
                    } else if (!attribute.isOwner() && !attribute.getConnectedAttribute().isOwner()) {//if both false
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Both are not owner so automatic adding owner role (not mappedBy) to ").append(attribute.getName()).append('\n');
                            IO.getErr().print(message.toString());
                        }
                            attribute.setOwner(true);
                            manageSiblingAttribute(managedClass, attribute);
                        }
                } else {
                    if (!attribute.isOwner()) {
                    if (IO != null) {
                        StringBuilder message = new StringBuilder();
                        message.append("Repair action > ").append(managedClass.getClazz()).append('[').append(attribute.getName()).append("]: ");
                        message.append("It is Unidirection relationship so automatic adding owner role and removing mappedBy").append('\n');
                        IO.getErr().print(message.toString());
                    }
                        attribute.setOwner(true);
                        manageSiblingAttribute(managedClass, attribute);
                    }
                }
            }
        }
    }

    // Issue Fix #5949 End
    /**
     * @return the theme
     */
    public String getTheme() {
        return theme;
    }

    /**
     * @param theme the theme to set
     */
    public void setTheme(String theme) {
        this.theme = theme;
    }

    public List<JavaClass> getJavaClass() {
        List<JavaClass> javaClassList = new ArrayList<>(this.getEntity());
        javaClassList.addAll(this.getMappedSuperclass());
        javaClassList.addAll(this.getEmbeddable());
        return javaClassList;
    }

    public JavaClass getJavaClass(String classId) {
        if(StringUtils.isBlank(classId)){
            return null;
        }
        List<JavaClass> javaClassList = new ArrayList<>(this.getEntity());
        javaClassList.addAll(this.getMappedSuperclass());
        javaClassList.addAll(this.getEmbeddable());
        for (JavaClass javaClass : javaClassList) {
            if (StringUtils.equals(javaClass.getId(),classId)) {
                return javaClass;
            }
        }
        return null;
    }
    public List<JavaClass> getAllJavaClass() {
        List<JavaClass> classes = new ArrayList<>();
        classes.addAll(getEntity());
        classes.addAll(getMappedSuperclass());
        classes.addAll(getEmbeddable());
        classes.addAll(getDefaultClass());
        return classes;
    }
     public List<JavaClass> findAllJavaClass(String className) {
        return getAllJavaClass().stream().filter((_class) -> (className.equals(_class.getClazz()))).collect(toList());
    }

    public List<JavaClass> getSubClass(String classId) {
        List<JavaClass> javaClassList = new ArrayList<JavaClass>(this.getEntity());
        this.getJavaClass().stream().filter((javaClass) -> (classId.equals(javaClass.getSuperclass().getId()))).forEach((javaClass) -> {
            javaClassList.add(javaClass);
        });
        return javaClassList;
    }

    public List<JavaClass> getAllSubClass(String classId) {
        List<JavaClass> javaClassList = new ArrayList<>();
        for (JavaClass javaClass : this.getJavaClass()) {
            if (javaClass.getSuperclass() != null && classId.equals(javaClass.getSuperclass().getId())) {
                javaClassList.add(javaClass);
                javaClassList.addAll(this.getAllSubClass(javaClass.getId()));
            }
        }
        return javaClassList;
    }

    @Override
    public String getName() {
        return persistenceUnitName;
    }

    @Override
    public void setName(String persistenceUnitName) {
        this.persistenceUnitName = persistenceUnitName;
    }

    /**
     * @return the jaxbSupport
     */
    public Boolean getJaxbSupport() {
        return jaxbSupport;
    }

    /**
     * @param jaxbSupport the jaxbSupport to set
     */
    public void setJaxbSupport(Boolean jaxbSupport) {
        this.jaxbSupport = jaxbSupport;
    }

    /**
     * @return the jaxbNameSpace
     */
    public String getJaxbNameSpace() {
        return jaxbNameSpace;
    }

    /**
     * @param jaxbNameSpace the jaxbNameSpace to set
     */
    public void setJaxbNameSpace(String jaxbNameSpace) {
        this.jaxbNameSpace = jaxbNameSpace;
    }

    public static EntityMappings getNewInstance(String version) {

        EntityMappings entityMappingsSpec = new EntityMappings();
        entityMappingsSpec.setId(NBModelerUtil.getAutoGeneratedStringId());
        entityMappingsSpec.setVersion(version);
        entityMappingsSpec.setPreviousVersion(version);
        Diagram diagram = new Diagram();
        Plane plane = new Plane();
        diagram.setJPAPlane(plane);
        plane.setElementRef(entityMappingsSpec.getId());
        entityMappingsSpec.setJPADiagram(diagram);
        entityMappingsSpec.getSnippets().add(DEAFULT);

        return entityMappingsSpec;
    }

    public List<SqlResultSetMapping> getAllSqlResultSetMappings() {
        List<IdentifiableClass> identifiableClasses = new ArrayList<>(this.getEntity());
        identifiableClasses.addAll(this.getMappedSuperclass());
        List<SqlResultSetMapping> sqlResultSetMappings = new ArrayList<>();
        identifiableClasses.stream().forEach((identifiableClass) -> {
            sqlResultSetMappings.addAll(identifiableClass.getSqlResultSetMapping());
        });
        return sqlResultSetMappings;
    }

    /**
     * @return the cache
     */
    public Cache getCache() {
        if (cache == null) {
            cache = new Cache();
        }
        return cache;
    }

    /**
     * @param cache the cache to set
     */
    public void setCache(Cache cache) {
        this.cache = cache;
    }

    void afterUnmarshal(Unmarshaller u, Object parent) {
        if(StringUtils.isBlank(_package) && StringUtils.isNotBlank(_package_dep)){
            _package = _package_dep;//TODO remove in future release // compatibility support
            _package_dep = null;
        }
        setPreviousVersion(version);
    }

    /**
     * @param previousVersion the previousVersion to set
     */
    public void setPreviousVersion(String previousVersion) {
        if(StringUtils.isBlank(previousVersion)){
            previousVersion = "0.0";
        }
        this.previousVersion = new SoftwareVersion(previousVersion);
    }

    /**
     * @return the previousVersion
     */
    public SoftwareVersion getPreviousVersion() {
        return previousVersion;
    }

    /**
     * @return the diagramVersion
     */
    public String getDiagramVersion() {
        return diagramVersion;
    }

    /**
     * @param diagramVersion the diagramVersion to set
     */
    public void setDiagramVersion(String diagramVersion) {
        this.diagramVersion = diagramVersion;
    }

    /**
     * @return the generateStaticMetamodel
     */
    public Boolean getGenerateStaticMetamodel() {
        return generateStaticMetamodel;
    }

    /**
     * @param generateStaticMetamodel the generateStaticMetamodel to set
     */
    public void setGenerateStaticMetamodel(Boolean generateStaticMetamodel) {
        this.generateStaticMetamodel = generateStaticMetamodel;
    }
    
    public List<ManagedClass> getAllManagedClass() {
        List<ManagedClass> managedClasses = new ArrayList<>();
        managedClasses.addAll(getEntity());
        managedClasses.addAll(getMappedSuperclass());
        managedClasses.addAll(getEmbeddable());
        return managedClasses;
    }

    /**
     * @return the staticMetamodelPackage
     */
    public String getStaticMetamodelPackage() {
        return staticMetamodelPackage;
    }

    /**
     * @param staticMetamodelPackage the staticMetamodelPackage to set
     */
    public void setStaticMetamodelPackage(String staticMetamodelPackage) {
        this.staticMetamodelPackage = staticMetamodelPackage;
    }

    /**
     * @return the dbTheme
     */
    public String getDbTheme() {
        return dbTheme;
    }

    /**
     * @param dbTheme the dbTheme to set
     */
    public void setDbTheme(String dbTheme) {
        this.dbTheme = dbTheme;
    }
        /**
     * @return the snippets
     */
    public List<Snippet> getSnippets() {
        if(snippets==null){
            snippets = new ArrayList<>();
        }
        return snippets;
    }

    /**
     * @param snippets the snippets to set
     */
    public void setSnippets(List<Snippet> snippets) {
        this.snippets = snippets;
    }

     public boolean addSnippet(Snippet snippet) {
        return getSnippets().add(snippet);
    }

    public boolean removeSnippet(Snippet snippet) {
        return getSnippets().remove(snippet);
    }
}
