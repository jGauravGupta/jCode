//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2014.01.21 at 01:52:19 PM IST
//
package org.netbeans.jpa.modeler.spec;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import java.util.stream.Stream;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlIDREF;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.commons.lang.StringUtils;
import org.netbeans.jcode.core.util.JavaSourceHelper;
import org.netbeans.jpa.modeler.spec.design.Diagram;
import org.netbeans.jpa.modeler.spec.design.Plane;
import org.netbeans.jpa.modeler.spec.extend.Attribute;
import org.netbeans.jpa.modeler.spec.extend.BaseElement;
import org.netbeans.jpa.modeler.spec.extend.ClassSnippet;
import org.netbeans.jpa.modeler.spec.extend.JavaClass;
import org.netbeans.jpa.modeler.spec.extend.MapKeyHandler;
import org.netbeans.jpa.modeler.spec.extend.MultiRelationAttribute;
import org.netbeans.jpa.modeler.spec.extend.ReferenceClass;
import org.netbeans.jpa.modeler.spec.extend.RelationAttribute;
import org.netbeans.jpa.modeler.spec.extend.ClassSnippetLocationType;
import org.netbeans.jpa.modeler.spec.extend.IPersistenceAttributes;
import org.netbeans.jpa.modeler.spec.extend.MapKeyType;
import org.netbeans.modeler.specification.version.SoftwareVersion;
import org.netbeans.jpa.modeler.spec.extend.cache.Cache;
import org.netbeans.jpa.modeler.spec.jsonb.JsonbDateFormat;
import org.netbeans.jpa.modeler.spec.jsonb.JsonbNumberFormat;
import org.netbeans.jpa.modeler.spec.jsonb.JsonbVisibilityHandler;
import org.netbeans.jpa.modeler.spec.jsonb.PropertyNamingStrategy;
import org.netbeans.jpa.modeler.spec.jsonb.PropertyOrderStrategy;
import org.netbeans.jpa.modeler.spec.workspace.WorkSpace;
import org.netbeans.jpa.modeler.spec.workspace.WorkSpaceItem;
import org.netbeans.modeler.core.NBModelerUtil;
import org.netbeans.modeler.core.exception.InvalidElmentException;
import org.netbeans.modeler.specification.model.document.IDefinitionElement;
import org.netbeans.modeler.specification.model.document.IRootElement;
import org.netbeans.modeler.specification.model.document.core.IBaseElement;
import org.openide.windows.InputOutput;

/**
 *
 *
 * The entity-mappings element is the root element of a mapping file. It
 * contains the following four types of elements:
 *
 * 1. The persistence-unit-metadata element contains metadata for the entire
 * persistence unit. It is undefined if this element occurs in multiple mapping
 * files within the same persistence unit.
 *
 * 2. The package, schema, catalog and access elements apply to all of the
 * entity, mapped-superclass and embeddable elements defined in the same file in
 * which they occur.
 *
 * 3. The sequence-generator, table-generator, converter, named-query,
 * named-native-query, named-stored-procedure-query, and sql-result-set-mapping
 * elements are global to the persistence unit. It is undefined to have more
 * than one sequence-generator or table-generator of the same name in the same
 * or different mapping files in a persistence unit. It is undefined to have
 * more than one named-query, named-native-query, sql-result-set-mapping, or
 * named-stored-procedure-query of the same name in the same or different
 * mapping files in a persistence unit. It is also undefined to have more than
 * one converter for the same target type in the same or different mapping files
 * in a persistence unit.
 *
 * 4. The entity, mapped-superclass and embeddable elements each define the
 * mapping information for a managed persistent class. The mapping information
 * contained in these elements may be complete or it may be partial.
 *
 *
 *
 * <p>
 * Java class for anonymous complex type.
 *
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="description" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="persistence-unit-metadata" type="{http://java.sun.com/xml/ns/persistence/orm}persistence-unit-metadata" minOccurs="0"/>
 *         &lt;element name="package" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="schema" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="catalog" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="access" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}access-type" minOccurs="0"/>
 *         &lt;element name="sequence-generator" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}sequence-generator" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="table-generator" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}table-generator" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-native-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-native-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="named-stored-procedure-query" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}named-stored-procedure-query" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="sql-result-set-mapping" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}sql-result-set-mapping" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="mapped-superclass" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}mapped-superclass" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="entity" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}entity" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="embeddable" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}embeddable" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="converter" type="{http://xmlns.jcp.org/xml/ns/persistence/orm}converter" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *       &lt;attribute name="version" use="required" type="{http://java.sun.com/xml/ns/persistence/orm}versionType" fixed="2.0" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 *
 */
@XmlType(name = "entity-mappings", propOrder = {
    "description",
    "persistenceUnitMetadata",
    "schema",
    "catalog",
    "access",
    "sequenceGenerator",
    "tableGenerator",
    "namedQuery",
    "namedNativeQuery",
    "namedStoredProcedureQuery",
    "sqlResultSetMapping",
    "mappedSuperclass",
    "entity",
    "embeddable",
    "converter",
    "snippets",
    "interfaces",
    "cache",
    "jsonbDateFormat",
    "jsonbNumberFormat",
    "jsonbVisibility",
    "jpaDiagram",
    "workSpaces"
})
@XmlRootElement(name = "entity-mappings")
@XmlAccessorType(XmlAccessType.FIELD)
public class EntityMappings extends BaseElement implements IDefinitionElement, IRootElement, 
        org.netbeans.modeler.properties.type.Embedded, JsonbVisibilityHandler {

    private static final String DEFAULT_PU_NAME = "DEFAULT_PU";

    protected String description;
    @XmlElement(name = "persistence-unit-metadata")
    protected PersistenceUnitMetadata persistenceUnitMetadata;
    @XmlAttribute(name = "pkg")
    protected String _package;
    protected String schema;
    protected String catalog;
    protected AccessType access;
    @XmlElement(name = "sequence-generator")
    protected List<SequenceGenerator> sequenceGenerator;
    @XmlElement(name = "table-generator")
    protected List<TableGenerator> tableGenerator;
    @XmlElement(name = "nq")//(name = "named-query")
    protected List<NamedQuery> namedQuery;
    @XmlElement(name = "nnq")//(name = "named-native-query")
    protected List<NamedNativeQuery> namedNativeQuery;
    @XmlElement(name = "nspq")//(name = "named-stored-procedure-query")
    protected List<NamedStoredProcedureQuery> namedStoredProcedureQuery; 
    @XmlElement(name = "srsm")//(name = "sql-result-set-mapping")
    protected Set<SqlResultSetMapping> sqlResultSetMapping;

    @XmlTransient
    private List<DefaultClass> defaultClass;
    @XmlElement(name = "mapped-superclass")
    protected List<MappedSuperclass> mappedSuperclass;
    protected List<Entity> entity;
    protected List<Embeddable> embeddable;
    protected List<Converter> converter;//NREVENG 
    @XmlAttribute(name = "v", required = true)
    protected String version;
    @XmlTransient
    private SoftwareVersion previousVersion;
    @XmlAttribute(name = "dv")
    private String diagramVersion;
    @XmlElement(name = "diagram")
    private Diagram jpaDiagram;//Custom Added
    
    @XmlAttribute(name = "rws")
    @XmlIDREF
    private WorkSpace rootWorkSpace;
    @XmlAttribute(name = "Pws")
    @XmlIDREF
    private WorkSpace previousWorkSpace;
    @XmlAttribute(name = "cws")
    @XmlIDREF
    private WorkSpace currentWorkSpace;
    @XmlAttribute(name = "nws")
    @XmlIDREF
    private WorkSpace nextWorkSpace;
    @XmlElementWrapper(name = "wsl")
    @XmlElement(name = "ws")
    private List<WorkSpace> workSpaces;
    
    @XmlAttribute
    private String status;//GENERATED (DBRE,JCRE)
    @XmlAttribute(name = "thm")
    private String theme;
    @XmlAttribute(name = "dbthm")
    private String dbTheme;
    @XmlAttribute(name = "jbthm")
    private String jbTheme;
    @XmlAttribute
    private String persistenceUnitName;

    @XmlElement(name = "c")
    private Cache cache;
    @XmlAttribute(name = "sm")
    private Boolean generateStaticMetamodel = false;
    @XmlAttribute(name = "smpkg")
    private String staticMetamodelPackage;

    /**
     * JAXB support
     */
    @XmlAttribute(name = "xs")
    private Boolean jaxbSupport;
    
    @XmlAttribute(name = "xn")
    private String jaxbNameSpace;
    
    //Jsonb support start
    
    @XmlAttribute(name = "jbpns")
    private PropertyNamingStrategy jsonbPropertyNamingStrategy;
    
    @XmlAttribute(name = "jbpos")
    private PropertyOrderStrategy jsonbPropertyOrderStrategy;   
        
    @XmlAttribute(name = "jbn")
    private Boolean jsonbNillable;
    
    @XmlElement(name = "jbdf")
    private JsonbDateFormat jsonbDateFormat;
        
    @XmlElement(name = "jbnf")
    private JsonbNumberFormat jsonbNumberFormat;   
        
    @XmlElement(name = "jbv")
    private ReferenceClass jsonbVisibility;

    //Jsonb support end
    
    @XmlElement(name = "snp")
    private List<ClassSnippet> snippets;

    @XmlElement(name = "inf")
    private Set<ReferenceClass> interfaces;

    private static final ClassSnippet DEAFULT_SNIPPET;
    private static final ReferenceClass DEAFULT_INTERFACE;

    static {
        DEAFULT_SNIPPET = new ClassSnippet();
        DEAFULT_SNIPPET.setValue("/**\n"
                + " * This file was generated by the Jeddict\n"
                + " */");
        DEAFULT_SNIPPET.setLocationType(ClassSnippetLocationType.BEFORE_PACKAGE);

        DEAFULT_INTERFACE = new ReferenceClass(Serializable.class.getCanonicalName());
    }

    private EntityMappings() {
    }

    public void initJavaInheritanceMapping() {
        List<JavaClass> javaClassList = this.getJavaClass();
        javaClassList.stream().filter((javaClass) -> (javaClass.getSuperclassId() != null)).forEach((javaClass) -> {
            JavaClass javaSuperclass = getJavaClass(javaClass.getSuperclassId());
            javaClass.addSuperclass(javaSuperclass);
        });
    }

    //UPDATE ELEMENT
    public boolean isClassExist(String _class) {
        if (mappedSuperclass != null) {
            if (mappedSuperclass.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (entity != null) {
            if (entity.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }
        if (embeddable != null) {
            if (embeddable.stream().anyMatch((e) -> (e.getClazz() != null && e.getClazz().equals(_class)))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Gets the value of the description property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * Gets the value of the persistenceUnitMetadata property.
     *
     * @return possible object is {@link PersistenceUnitMetadata }
     *
     */
    public PersistenceUnitMetadata getPersistenceUnitMetadata() {
        return persistenceUnitMetadata;
    }

    /**
     * Sets the value of the persistenceUnitMetadata property.
     *
     * @param value allowed object is {@link PersistenceUnitMetadata }
     *
     */
    public void setPersistenceUnitMetadata(PersistenceUnitMetadata value) {
        this.persistenceUnitMetadata = value;
    }

    /**
     * Gets the value of the package property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getPackage() {
        if (StringUtils.isBlank(_package)) {
            return null;
        }
        return _package;
    }

    /**
     * Sets the value of the package property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setPackage(String value) {
        this._package = value;
    }

    /**
     * Gets the value of the schema property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getSchema() {
        return schema;
    }

    /**
     * Sets the value of the schema property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setSchema(String value) {
        this.schema = value;
    }

    /**
     * Gets the value of the catalog property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getCatalog() {
        return catalog;
    }

    /**
     * Sets the value of the catalog property.
     *
     * @param value allowed object is {@link String }
     *
     */
    public void setCatalog(String value) {
        this.catalog = value;
    }

    /**
     * Gets the value of the access property.
     *
     * @return possible object is {@link AccessType }
     *
     */
    public AccessType getAccess() {
        return access;
    }

    /**
     * Sets the value of the access property.
     *
     * @param value allowed object is {@link AccessType }
     *
     */
    public void setAccess(AccessType value) {
        this.access = value;
    }

    /**
     * Gets the value of the sequenceGenerator property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the sequenceGenerator property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSequenceGenerator().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SequenceGenerator }
     *
     *
     */
    public List<SequenceGenerator> getSequenceGenerator() {
        if (sequenceGenerator == null) {
            sequenceGenerator = new ArrayList<SequenceGenerator>();
        }
        return this.sequenceGenerator;
    }

    /**
     * Gets the value of the tableGenerator property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the tableGenerator property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTableGenerator().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TableGenerator }
     *
     *
     */
    public List<TableGenerator> getTableGenerator() {
        if (tableGenerator == null) {
            tableGenerator = new ArrayList<TableGenerator>();
        }
        return this.tableGenerator;
    }

    /**
     * Gets the value of the namedQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedQuery }
     *
     *
     */
    public List<NamedQuery> getNamedQuery() {
        if (namedQuery == null) {
            namedQuery = new ArrayList<NamedQuery>();
        }
        return this.namedQuery;
    }

    /**
     * Gets the value of the namedNativeQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedNativeQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedNativeQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedNativeQuery }
     *
     *
     */
    public List<NamedNativeQuery> getNamedNativeQuery() {
        if (namedNativeQuery == null) {
            namedNativeQuery = new ArrayList<NamedNativeQuery>();
        }
        return this.namedNativeQuery;
    }

    /**
     * Gets the value of the namedStoredProcedureQuery property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the namedStoredProcedureQuery property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNamedStoredProcedureQuery().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NamedStoredProcedureQuery }
     *
     *
     */
    public List<NamedStoredProcedureQuery> getNamedStoredProcedureQuery() {
        if (namedStoredProcedureQuery == null) {
            namedStoredProcedureQuery = new ArrayList<NamedStoredProcedureQuery>();
        }
        return this.namedStoredProcedureQuery;
    }

    /**
     * Gets the value of the sqlResultSetMapping property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the sqlResultSetMapping property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSqlResultSetMapping().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SqlResultSetMapping }
     *
     *
     */
    public Set<SqlResultSetMapping> getSqlResultSetMapping() {
        if (sqlResultSetMapping == null) {
            sqlResultSetMapping = new HashSet<SqlResultSetMapping>();
        }
        return this.sqlResultSetMapping;
    }

    /**
     * Gets the value of the mappedSuperclass property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the mappedSuperclass property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMappedSuperclass().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MappedSuperclass }
     *
     *
     */
    public List<MappedSuperclass> getMappedSuperclass() {
        if (mappedSuperclass == null) {
            mappedSuperclass = new ArrayList<MappedSuperclass>();
        }
        return this.mappedSuperclass;
    }

    public MappedSuperclass getMappedSuperclass(String id) {
        if (mappedSuperclass != null) {
            for (MappedSuperclass mappedSuperclass_In : mappedSuperclass) {
                if (id.equals(mappedSuperclass_In.getId())) {
                    return mappedSuperclass_In;
                }
            }
        }
        return null;
    }

    public void setMappedSuperclass(List<MappedSuperclass> mappedSuperclass) {
        if (this.mappedSuperclass == null) {
            this.mappedSuperclass = new ArrayList<>();
        }
        this.mappedSuperclass = mappedSuperclass;
    }
    /**
     * Gets the value of the entity property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the entity property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEntity().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list {@link Entity }
     *
     *
     * @return 
     */
    public List<Entity> getEntity() {
        if (entity == null) {
            entity = new ArrayList<>();
        }
        return this.entity;
    }

    public Stream<String> getFQEntity() {
        return getEntity().stream().map(Entity::getFQN);
    }

    public Stream<String> getFQConcreteEntity() {
        return getConcreteEntity().map(Entity::getFQN);
    }

    public Stream<Entity> getConcreteEntity() {
        return getEntity().stream().filter(e -> Boolean.FALSE.equals(e.getAbstract()));
    }
    
    public Stream<Entity> getGeneratedEntity() {
        return getEntity().stream()
                .filter(e -> Boolean.FALSE.equals(e.getAbstract()))
                .filter(e -> e.getGenerateSourceCode());
    }
    
    
    public void setEntity(List<Entity> entity) {
        if (this.entity == null) {
            this.entity = new ArrayList<>();
        }
        this.entity = entity;
    }

    /**
     * Gets the value of the embeddable property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the embeddable property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbeddable().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Embeddable }
     *
     *
     */
    public List<Embeddable> getEmbeddable() {
        if (embeddable == null) {
            embeddable = new ArrayList<Embeddable>();
        }
        return this.embeddable;
    }

    public void setEmbeddable(List<Embeddable> embeddable) {
        if (this.embeddable == null) {
            this.embeddable = new ArrayList<>();
        }
        this.embeddable = embeddable;
    }
    
    /**
     * Gets the value of the converter property.
     *
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the converter property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConverter().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Converter }
     *
     *
     */
    public List<Converter> getConverter() {
        if (converter == null) {
            converter = new ArrayList<>();
        }
        return this.converter;
    }
    
    public Optional<Converter> findConverter(String converter) {
        if (StringUtils.isBlank(converter)) {
            return Optional.empty();
        }
        for (Converter converter_In : getConverter()) {
            if (converter.equals(converter_In.getClazz())) {
                return Optional.of(converter_In);
            }
        }
        return Optional.empty();
    }
    
    public boolean addConverter(String converterClass, String attributeType, String dbFieldType) {
       Optional<Converter> existingConOpt = findConverter(converterClass);
       if(existingConOpt.isPresent()){
            Converter existingCon = existingConOpt.get();
            return attributeType.equals(existingCon.getAttributeType()) && dbFieldType.equals(existingCon.getFieldType());
       } else {
           Converter newConverter = new Converter();
           newConverter.setClazz(converterClass);
           newConverter.setFieldType(dbFieldType);
           newConverter.setAttributeType(attributeType);
           getConverter().add(newConverter);
           return true;
       }
    }

    /**
     * Gets the value of the version property.
     *
     * @return possible object is {@link String }
     *
     */
    public String getVersion() {
        if (StringUtils.isBlank(version)) {
            version = "0.0";
        }
        return version;
    }

    /**
     * Sets the value of the version property.
     *
     * @param value allowed object is {@link float }
     *
     */
    public void setVersion(String value) {
        this.version = value;
    }

    public void setVersion(SoftwareVersion value) {
        this.version = value.getValue();
    }

    @Override
    public void removeBaseElement(IBaseElement baseElement_In) {
        if (baseElement_In instanceof JavaClass) {
            if (baseElement_In instanceof Entity) {
                this.removeEntity((Entity) baseElement_In);
            } else if (baseElement_In instanceof MappedSuperclass) {
                this.removeMappedSuperclass((MappedSuperclass) baseElement_In);
            } else if (baseElement_In instanceof Embeddable) {
                this.removeEmbeddable((Embeddable) baseElement_In);
            } else {
                throw new InvalidElmentException("Invalid JPA Element");
            }
        } else {
            throw new InvalidElmentException("Invalid JPA Element");
        }
    }

    @Override
    public void addBaseElement(IBaseElement baseElement_In) {
        if (baseElement_In instanceof JavaClass) {
            if (baseElement_In instanceof Entity) {
                this.addEntity((Entity) baseElement_In);
            } else if (baseElement_In instanceof MappedSuperclass) {
                this.addMappedSuperclass((MappedSuperclass) baseElement_In);
            } else if (baseElement_In instanceof Embeddable) {
                this.addEmbeddable((Embeddable) baseElement_In);
            } else {
                throw new InvalidElmentException("Invalid JPA Element");
            }
            getCurrentWorkSpace().addItem(new WorkSpaceItem((JavaClass) baseElement_In));
        } else {
            throw new InvalidElmentException("Invalid JPA Element");
        }
    }

    public void removeEntity(Entity entity_In) {
        if (entity != null) {
            this.entity.remove(entity_In);
            entity_In.setRootElement(null);
        }
    }

    public void addEntity(Entity entity_In) {
        if (entity == null) {
            entity = new ArrayList<>();
        }
        this.entity.add(entity_In);
        entity_In.setRootElement(this);
    }

    public Optional<Entity> findEntity(String entityName) {
        if (StringUtils.isBlank(entityName)) {
            return Optional.empty();
        }
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (entityName.equals(entity_In.getClazz())) {
                    return Optional.of(entity_In);
                }
            }
        }
        return Optional.empty();
    }
    
    public Optional<? extends IdentifiableClass> findIdentifiableClass(String className) {
        if (StringUtils.isBlank(className)) {
            return Optional.empty();
        }
        Optional<Entity> entityOpt = findEntity(className);
        if (!entityOpt.isPresent()) {
            return findMappedSuperclass(className);
        } else {
            return entityOpt;
        }
    }

    public Entity getEntity(String id) {
        if (StringUtils.isBlank(id)) {
            return null;
        }
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (id.equals(entity_In.getId())) {
                    return entity_In;
                }
            }
        }
        return null;
    }

    public Embeddable getEmbeddable(String id) {
        if (StringUtils.isBlank(id)) {
            return null;
        }
        if (embeddable != null) {
            for (Embeddable embeddable_In : embeddable) {
                if (id.equals(embeddable_In.getId())) {
                    return embeddable_In;
                }
            }
        }
        return null;
    }

    public List<Entity> findAllEntity(String entityName) {
        if (StringUtils.isBlank(entityName)) {
            return null;
        }
        List<Entity> entities = new ArrayList<Entity>();
        if (entity != null) {
            for (Entity entity_In : entity) {
                if (entityName.equals(entity_In.getClazz())) {
                    entities.add(entity_In);
                }
            }
        }
        return entities;
    }

    public void removeMappedSuperclass(MappedSuperclass mappedSuperclass_In) {
        if (mappedSuperclass != null) {
            this.mappedSuperclass.remove(mappedSuperclass_In);
            mappedSuperclass_In.setRootElement(null);
        }
    }

    public void addMappedSuperclass(MappedSuperclass mappedSuperclass_In) {
        if (mappedSuperclass == null) {
            mappedSuperclass = new ArrayList<>();
        }
        this.mappedSuperclass.add(mappedSuperclass_In);
        mappedSuperclass_In.setRootElement(this);
    }

    public Optional<MappedSuperclass> findMappedSuperclass(String mappedSuperclassName) {
        if (StringUtils.isBlank(mappedSuperclassName)) {
            return Optional.empty();
        }
        if (mappedSuperclass != null) {
            for (MappedSuperclass mappedSuperclass_In : mappedSuperclass) {
                if (mappedSuperclassName.equals(mappedSuperclass_In.getClazz())) {
                    return Optional.of(mappedSuperclass_In);
                }
            }
        }
        return Optional.empty();
    }

    public void removeEmbeddable(Embeddable embeddable_In) {
        if (embeddable != null) {
            this.embeddable.remove(embeddable_In);
            embeddable_In.setRootElement(null);
        }
    }

    public void addEmbeddable(Embeddable embeddable_In) {
        if (embeddable == null) {
            embeddable = new ArrayList<>();
        }
        this.embeddable.add(embeddable_In);
        embeddable_In.setRootElement(this);
    }

    public Optional<Embeddable> findEmbeddable(String embeddableName) {
        if (StringUtils.isBlank(embeddableName)) {
            return Optional.empty();
        }
        if (embeddable != null) {
            for (Embeddable embeddable_In : embeddable) {
                if (embeddableName.equals(embeddable_In.getClazz())) {
                    return Optional.of(embeddable_In);
                }
            }
        }
        return Optional.empty();
    }

    /**
     * @return the jpaDiagram
     */
    @Deprecated
    public Diagram getJPADiagram() {
        return jpaDiagram;
    }

    /**
     * @param jpaDiagram the jpaDiagram to set
     */
    @Deprecated
    public void setJPADiagram(Diagram jpaDiagram) {
        this.jpaDiagram = jpaDiagram;
    }

    /**
     * @return the persistenceUnitName
     */
    public String getPersistenceUnitName() {
        if (persistenceUnitName == null) {
            return DEFAULT_PU_NAME;
        }
        return persistenceUnitName;
    }

    /**
     * @param persistenceUnitName the persistenceUnitName to set
     */
    public void setPersistenceUnitName(String persistenceUnitName) {
        this.persistenceUnitName = persistenceUnitName;
    }

    /**
     * @return the defaultClass
     */
    public List<DefaultClass> getDefaultClass() {
        if (this.defaultClass == null) {
            this.defaultClass = new ArrayList<DefaultClass>();
        }
        return defaultClass;
    }

    public DefaultClass addDefaultClass(String subPackage, String _class) {
        if (StringUtils.isBlank(_class)) {
            throw new IllegalStateException("Class name can't empty");
        }
        DefaultClass existDefaultClass;
//        Optional<DefaultClass> existDefaultClassOpt = findDefaultClass(_class);
//
//        if (!existDefaultClassOpt.isPresent()) {
            existDefaultClass = new DefaultClass(_class);
            existDefaultClass.setPackage(subPackage);
            existDefaultClass.setId(NBModelerUtil.getAutoGeneratedStringId());
            existDefaultClass.setRootElement(this);
            this.getDefaultClass().add(existDefaultClass);
//        } else {
//            existDefaultClass = existDefaultClassOpt.get();
//        }
        return existDefaultClass;
    }

    public Optional<DefaultClass> findDefaultClass(String _class) {
        if (this.defaultClass != null) {
            for (DefaultClass defaultClass_TMP : defaultClass) {
                if (defaultClass_TMP.getClazz().equals(_class)) {
                    return Optional.of(defaultClass_TMP);
                }
            }
        }
        return Optional.empty();
    }

    /**
     * @return the status
     */
    public String getStatus() {
        return status;
    }

    /**
     * @param status the status to set
     */
    public void setStatus(String status) {
        this.status = status;
    }

    public void setGenerated() {
        this.status = "GENERATED";
    }

    public boolean isGenerated() {
        if ("GENERATED".equals(this.status)) {
            return true;
        } else {
            return false;
        }
    }

    public List<IdentifiableClass> getIdentifiableClass() {
        List<IdentifiableClass> identifiableClasses = new ArrayList<>(getEntity());
        identifiableClasses.addAll(getMappedSuperclass());
        return identifiableClasses;
    }

    public void manageRefId() {
        EntityMappings entityMappingsSpec = this;

        getNamedStoredProcedureQuery().forEach(q -> manageStoredProcedureQuery(q));

        List<ManagedClass> classes = new ArrayList<>(entityMappingsSpec.getEntity());
        // manageSiblingAttribute for MappedSuperClass and Embeddable is not required for (DBRE) DB REV ENG CASE
        classes.addAll(entityMappingsSpec.getMappedSuperclass());
        classes.addAll(entityMappingsSpec.getEmbeddable());

        for (ManagedClass<? extends IPersistenceAttributes> managedClass : classes) {

            if (managedClass instanceof Entity) {
                ((Entity) managedClass).getNamedStoredProcedureQuery()
                        .forEach(q -> manageStoredProcedureQuery(q));
            }

            for (ManyToMany manyToMany : new ArrayList<>(managedClass.getAttributes().getManyToMany())) {
                if (manyToMany.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, manyToMany);
                    manageMapKeyAttribute(managedClass, manyToMany);
                }
            }
            for (OneToMany oneToMany : new ArrayList<>(managedClass.getAttributes().getOneToMany())) {
                if (oneToMany.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, oneToMany);
                    manageMapKeyAttribute(managedClass, oneToMany);
                }
            }
            for (ManyToOne manyToOne : new ArrayList<>(managedClass.getAttributes().getManyToOne())) {
                manageSiblingAttribute(managedClass, manyToOne);
            }
            for (OneToOne oneToOne : new ArrayList<>(managedClass.getAttributes().getOneToOne())) {
                if (oneToOne.getMappedBy() == null) {
                    manageSiblingAttribute(managedClass, oneToOne);
                }
            }

            for (ElementCollection elementCollection : new ArrayList<>(managedClass.getAttributes().getElementCollection())) {
                if (elementCollection.getMapKeyAttributeType() != null) {
                    manageMapKeyAttribute(managedClass, elementCollection);
                }
            }

            // If Include Referenced Classed Checkbox is Uncheked then remove attribute
            for (RelationAttribute relationAttribute : new ArrayList<>(managedClass.getAttributes().getRelationAttributes())) {
                Optional<org.netbeans.jpa.modeler.spec.Entity> targetEntity = entityMappingsSpec.findEntity(relationAttribute.getTargetEntity());
                if (!targetEntity.isPresent()) {
                    managedClass.getAttributes().removeRelationAttribute(relationAttribute);
                }
            }

        }

    }

    private void manageStoredProcedureQuery(NamedStoredProcedureQuery storedProcedureQuery) {
        for (String _class : new CopyOnWriteArrayList<>(storedProcedureQuery.getResultClass())) {
            String uqClass = JavaSourceHelper.getSimpleClassName(_class);
            this.findEntity(uqClass).ifPresent(targetEntity -> {
                storedProcedureQuery.getResultClass().remove(_class);
                storedProcedureQuery.addResultClass(targetEntity);
            });
        }

    }

    private void manageMapKeyAttribute(ManagedClass managedClass, MapKeyHandler mapKeyHandler) {
        if (mapKeyHandler.getMapKeyAttributeType() == null) {
            return;
        }
        loadMapKeyAttribute(managedClass, mapKeyHandler);
        mapKeyHandler.setMapKeyType(mapKeyHandler.getValidatedMapKeyType());
    }

    private void loadMapKeyAttribute(ManagedClass managedClass, MapKeyHandler mapKeyHandler) {
        if (mapKeyHandler.getMapKeyType() == MapKeyType.NEW) {
            //Search in Entity
            Optional<org.netbeans.jpa.modeler.spec.Entity> entity = this.findEntity(mapKeyHandler.getMapKeyAttributeType());
            if (entity.isPresent()) {
                mapKeyHandler.setMapKeyEntity(entity.get());
                return;
            }

            //Search in Embeddable
            Optional<Embeddable> embeddableOpt = this.findEmbeddable(mapKeyHandler.getMapKeyAttributeType());
            if (embeddableOpt.isPresent()) {
                mapKeyHandler.setMapKeyEmbeddable(embeddableOpt.get());
                return;
            }
        } else {
            //find Existing Attribute in current and connected class based on the instance
            if (mapKeyHandler.getMapKey() != null && StringUtils.isNotBlank(mapKeyHandler.getMapKey().getName())) {
                ManagedClass attributeContainerClass = null;
                if (mapKeyHandler instanceof ElementCollection) {
                    attributeContainerClass = managedClass;
                } else if (mapKeyHandler instanceof MultiRelationAttribute) {
                    MultiRelationAttribute multiRelationAttribute = (MultiRelationAttribute) mapKeyHandler;
                    attributeContainerClass = multiRelationAttribute.getConnectedEntity();
                }
                if (attributeContainerClass != null) {
                    List<Attribute> attributes = attributeContainerClass.getAttributes().findAllAttribute(mapKeyHandler.getMapKey().getName());
                    if (attributes != null && !attributes.isEmpty()) {
                        mapKeyHandler.setMapKeyAttribute(attributes.get(0));
                    }
                }
            }
        }
    }

    // Issue Fix #5949 Start
    private void manageSiblingAttribute(JavaClass sourceJavaClass, RelationAttribute relationAttribute_Owner) {
        Optional<org.netbeans.jpa.modeler.spec.Entity> targetEntityOptional = this.findEntity(relationAttribute_Owner.getTargetEntity());
        if (targetEntityOptional.isPresent()) {
            org.netbeans.jpa.modeler.spec.Entity targetEntity = targetEntityOptional.get();
            if (relationAttribute_Owner instanceof ManyToMany) {
                ManyToMany sourceAttribute = (ManyToMany) relationAttribute_Owner;
                ManyToMany targetAttribute = null;
                for (ManyToMany targetManyToMany : targetEntity.getAttributes().getManyToMany()) {
                    if (sourceAttribute.getName().equals(targetManyToMany.getMappedBy()) && sourceJavaClass.getClazz().equals(targetManyToMany.getTargetEntity())) {
                        targetAttribute = targetManyToMany;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);
            } else if (relationAttribute_Owner instanceof OneToMany) {
                OneToMany sourceAttribute = (OneToMany) relationAttribute_Owner;
                sourceAttribute.setConnectedEntity(targetEntity);
            } else if (relationAttribute_Owner instanceof ManyToOne) {
                ManyToOne sourceAttribute = (ManyToOne) relationAttribute_Owner;
                OneToMany targetAttribute = null;
                for (OneToMany targetOneToMany : targetEntity.getAttributes().getOneToMany()) {
                    if (sourceAttribute.getName().equals(targetOneToMany.getMappedBy()) && sourceJavaClass.getClazz().equals(targetOneToMany.getTargetEntity())) {
                        targetAttribute = targetOneToMany;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);

            } else if (relationAttribute_Owner instanceof OneToOne) {
                OneToOne sourceAttribute = (OneToOne) relationAttribute_Owner;
                OneToOne targetAttribute = null;
                for (OneToOne targetOneToOne : targetEntity.getAttributes().getOneToOne()) {
                    if (sourceAttribute.getName().equals(targetOneToOne.getMappedBy()) && sourceJavaClass.getClazz().equals(targetOneToOne.getTargetEntity())) {
                        targetAttribute = targetOneToOne;
                        break;
                    }
                }
                if (targetAttribute != null) {
                    targetAttribute.setConnectedEntity((Entity) sourceJavaClass);
                    targetAttribute.setConnectedAttribute(sourceAttribute);
                    sourceAttribute.setConnectedAttribute(targetAttribute);
                }
                sourceAttribute.setConnectedEntity(targetEntity);

            }
        }
    }
//
//    public void repairDefinition(boolean manageSiblingAttribute) {
//        repairDefinition(null, manageSiblingAttribute);
//    }

    public void repairDefinition(InputOutput IO) {
        repairDefinition(IO, false);
    }

    /**
     * Helps in compatibility support, helps to repair wrong jpa relation in
     * JCRE
     *
     * @param IO
     * @param manageSiblingAttribute
     */
    public void repairDefinition(InputOutput IO, boolean manageSiblingAttribute) {

        for (ManagedClass<IPersistenceAttributes> managedClass : this.getAllManagedClass()) {
            for (RelationAttribute attribute : managedClass.getAttributes().getRelationAttributes()) {
                //if no connected-entity-id exist
                if (attribute.getConnectedEntity() == null) {
                    if (IO != null) {
                        StringBuilder message = new StringBuilder();
                        message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                        message.append(attribute.getName()).append("]: ");
                        message.append("No connected entity reference found, so removing attribute").append('\n');
                        IO.getErr().print(message.toString());
                    }
                    if (attribute.getConnectedAttribute() != null) {
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Also removing connected attribute").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        //remove the connected attribute from its owning class
                        ((ManagedClass<IPersistenceAttributes>) attribute.getConnectedAttribute().getJavaClass()).getAttributes().removeRelationAttribute(attribute.getConnectedAttribute());
                    }
                    //remove to self from owning class
                    managedClass.getAttributes().removeRelationAttribute(attribute);
                    continue;
                }
                //if own is missing/found form both side
                if (attribute.getConnectedAttribute() != null) {
                    if (attribute.isOwner() && attribute.getConnectedAttribute().isOwner()) {//if both true
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Both are owner so automatic removing owner role from ").append(attribute.getConnectedAttribute().getName()).append(" (converting to mappedBy)").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.getConnectedAttribute().setOwner(false);
                    } else if (!attribute.isOwner() && !attribute.getConnectedAttribute().isOwner()) {//if both false
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[');
                            message.append(attribute.getName()).append(" -> ").append(attribute.getConnectedAttribute().getName()).append("]: ");
                            message.append("Both are not owner so automatic adding owner role (not mappedBy) to ").append(attribute.getName()).append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.setOwner(true);
                        manageSiblingAttribute(managedClass, attribute);
                    }
                } else {
                    if (!attribute.isOwner()) {
                        if (IO != null) {
                            StringBuilder message = new StringBuilder();
                            message.append("Repair action > ").append(managedClass.getClazz()).append('[').append(attribute.getName()).append("]: ");
                            message.append("It is Unidirection relationship so automatic adding owner role and removing mappedBy").append('\n');
                            IO.getErr().print(message.toString());
                        }
                        attribute.setOwner(true);
                        manageSiblingAttribute(managedClass, attribute);
                    }
                }
            }
        }
    }

    // Issue Fix #5949 End
    /**
     * @return the theme
     */
    public String getTheme() {
        return theme;
    }

    /**
     * @param theme the theme to set
     */
    public void setTheme(String theme) {
        this.theme = theme;
    }

    public List<ManagedClass> getManagedClass() {
        List<ManagedClass> managedClassList = new ArrayList<>(this.getEntity());
        managedClassList.addAll(this.getMappedSuperclass());
        managedClassList.addAll(this.getEmbeddable());
        return managedClassList;
    }
        
    public List<JavaClass> getJavaClass() {
        List<JavaClass> javaClassList = new ArrayList<>(this.getManagedClass());
        return javaClassList;
    }

    public JavaClass getJavaClass(String classId) {
        if (StringUtils.isBlank(classId)) {
            return null;
        }
        List<JavaClass> javaClassList = new ArrayList<>(this.getEntity());
        javaClassList.addAll(this.getMappedSuperclass());
        javaClassList.addAll(this.getEmbeddable());
        for (JavaClass javaClass : javaClassList) {
            if (StringUtils.equals(javaClass.getId(), classId)) {
                return javaClass;
            }
        }
        return null;
    }

    public List<JavaClass> getAllJavaClass() {
        List<JavaClass> classes = new ArrayList<>();
        classes.addAll(getEntity());
        classes.addAll(getMappedSuperclass());
        classes.addAll(getEmbeddable());
        classes.addAll(getDefaultClass());
        return classes;
    }

    public List<JavaClass> findAllJavaClass(String className) {
        return getAllJavaClass().stream().filter((_class) -> (className.equals(_class.getClazz()))).collect(toList());
    }

    public List<JavaClass> getSubClass(String classId) {
        List<JavaClass> javaClassList = new ArrayList<JavaClass>(this.getEntity());
        this.getJavaClass().stream().filter((javaClass) -> (classId.equals(javaClass.getSuperclass().getId()))).forEach((javaClass) -> {
            javaClassList.add(javaClass);
        });
        return javaClassList;
    }

    public List<JavaClass> getAllSubClass(String classId) {
        List<JavaClass> javaClassList = new ArrayList<>();
        for (JavaClass javaClass : this.getJavaClass()) {
            if (javaClass.getSuperclass() != null && classId.equals(javaClass.getSuperclass().getId())) {
                javaClassList.add(javaClass);
                javaClassList.addAll(this.getAllSubClass(javaClass.getId()));
            }
        }
        return javaClassList;
    }

    @Override
    public String getName() {
        return persistenceUnitName;
    }

    @Override
    public void setName(String persistenceUnitName) {
        this.persistenceUnitName = persistenceUnitName;
    }

    /**
     * @return the jaxbNameSpace
     */
    public String getJaxbNameSpace() {
        return jaxbNameSpace;
    }

    /**
     * @param jaxbNameSpace the jaxbNameSpace to set
     */
    public void setJaxbNameSpace(String jaxbNameSpace) {
        this.jaxbNameSpace = jaxbNameSpace;
    }

    public static EntityMappings getNewInstance(String version) {

        EntityMappings entityMappingsSpec = new EntityMappings();
        entityMappingsSpec.setId(NBModelerUtil.getAutoGeneratedStringId());
        entityMappingsSpec.setVersion(version);
        entityMappingsSpec.setPreviousVersion(version);
        Diagram diagram = new Diagram();
        Plane plane = new Plane();
        diagram.setJPAPlane(plane);
        plane.setElementRef(entityMappingsSpec.getId());
        entityMappingsSpec.setJPADiagram(diagram);
        entityMappingsSpec.getSnippets().add(DEAFULT_SNIPPET);
//        entityMappingsSpec.getInterfaces().add(DEAFULT_INTERFACE);

        return entityMappingsSpec;
    }

    public List<SqlResultSetMapping> getAllSqlResultSetMappings() {
        List<IdentifiableClass> identifiableClasses = new ArrayList<>(this.getEntity());
        identifiableClasses.addAll(this.getMappedSuperclass());
        List<SqlResultSetMapping> sqlResultSetMappings = new ArrayList<>();
        identifiableClasses.stream().forEach((identifiableClass) -> {
            sqlResultSetMappings.addAll(identifiableClass.getSqlResultSetMapping());
        });
        return sqlResultSetMappings;
    }

    /**
     * @return the cache
     */
    public Cache getCache() {
        if (cache == null) {
            cache = new Cache();
        }
        return cache;
    }

    /**
     * @param cache the cache to set
     */
    public void setCache(Cache cache) {
        this.cache = cache;
    }

    void afterUnmarshal(Unmarshaller u, Object parent) {
        setPreviousVersion(version);
    }

    /**
     * @param previousVersion the previousVersion to set
     */
    public void setPreviousVersion(String previousVersion) {
        if (StringUtils.isBlank(previousVersion)) {
            previousVersion = "0.0";
        }
        this.previousVersion = new SoftwareVersion(previousVersion);
    }

    /**
     * @return the previousVersion
     */
    public SoftwareVersion getPreviousVersion() {
        return previousVersion;
    }

    /**
     * @return the diagramVersion
     */
    public String getDiagramVersion() {
        return diagramVersion;
    }

    /**
     * @param diagramVersion the diagramVersion to set
     */
    public void setDiagramVersion(String diagramVersion) {
        this.diagramVersion = diagramVersion;
    }

    /**
     * @return the generateStaticMetamodel
     */
    public Boolean getGenerateStaticMetamodel() {
        return generateStaticMetamodel;
    }

    /**
     * @param generateStaticMetamodel the generateStaticMetamodel to set
     */
    public void setGenerateStaticMetamodel(Boolean generateStaticMetamodel) {
        this.generateStaticMetamodel = generateStaticMetamodel;
    }

    public List<ManagedClass> getAllManagedClass() {
        List<ManagedClass> managedClasses = new ArrayList<>();
        managedClasses.addAll(getEntity());
        managedClasses.addAll(getMappedSuperclass());
        managedClasses.addAll(getEmbeddable());
        return managedClasses;
    }

    /**
     * @return the staticMetamodelPackage
     */
    public String getStaticMetamodelPackage() {
        return staticMetamodelPackage;
    }

    /**
     * @param staticMetamodelPackage the staticMetamodelPackage to set
     */
    public void setStaticMetamodelPackage(String staticMetamodelPackage) {
        this.staticMetamodelPackage = staticMetamodelPackage;
    }

    /**
     * @return the dbTheme
     */
    public String getDbTheme() {
        return dbTheme;
    }

    /**
     * @param dbTheme the dbTheme to set
     */
    public void setDbTheme(String dbTheme) {
        this.dbTheme = dbTheme;
    }

    /**
     * @return the snippets
     */
    public List<ClassSnippet> getSnippets() {
        if (snippets == null) {
            snippets = new ArrayList<>();
        }
        return snippets;
    }

    /**
     * @param snippets the snippets to set
     */
    public void setSnippets(List<ClassSnippet> snippets) {
        this.snippets = snippets;
    }

    public boolean addSnippet(ClassSnippet snippet) {
        return getSnippets().add(snippet);
    }

    public boolean removeSnippet(ClassSnippet snippet) {
        return getSnippets().remove(snippet);
    }

    public void addInterface(ReferenceClass _interface) {
        this.getInterfaces().add(_interface);
    }

    public void removeInterface(ReferenceClass _interface) {
        this.getInterfaces().remove(_interface);
    }

    /**
     * @return the interfaces
     */
    public Set<ReferenceClass> getInterfaces() {
        if (this.interfaces == null) {
            this.interfaces = new LinkedHashSet<>();
        }
        return interfaces;
    }

    /**
     * @param interfaces the interfaces to set
     */
    public void setInterfaces(Set<ReferenceClass> interfaces) {
        this.interfaces = interfaces;
    }
    
    public Set<String> getAllConvert(){
        Set<String> converts = new HashSet<>();
        for (Entity clazz : getEntity()) {
            converts.addAll(clazz.getAllConvert());
        }
        for (MappedSuperclass clazz : getMappedSuperclass()) {
            converts.addAll(clazz.getAllConvert());
        }
        for (Embeddable clazz : getEmbeddable()) {
            converts.addAll(clazz.getAllConvert());
        }
        return converts;
    }

    public void cleanRuntimeArtifact(){
        for (JavaClass javaClass : getJavaClass()) {
            javaClass.setRuntimeAnnotation(null);
            javaClass.setRuntimeSnippets(null);
            List<? extends Attribute> attributes = null;
            if(javaClass instanceof ManagedClass){
                attributes = ((ManagedClass)javaClass).getAttributes().getAllAttribute();
            } else if(javaClass instanceof DefaultClass){
                attributes = ((DefaultClass)javaClass).getAttributes().getDefaultAttributes();
            }
            if (attributes != null) {
                attributes.forEach(attr -> {
                    attr.setRuntimeAnnotation(null);
                    attr.setRuntimeSnippets(null);
                });
            }
        }
    }

    /**
     * @return the rootWorkSpace
     */
    public WorkSpace getRootWorkSpace() {
        if(rootWorkSpace == null){
            rootWorkSpace = new WorkSpace();
            rootWorkSpace.setId(NBModelerUtil.getAutoGeneratedStringId());
            rootWorkSpace.setName("Main");
            getWorkSpaces().add(rootWorkSpace);
        }
        return rootWorkSpace;
    }

    /**
     * @param rootWorkSpace the rootWorkSpace to set
     */
    public void setRootWorkSpace(WorkSpace rootWorkSpace) {
        this.rootWorkSpace = rootWorkSpace;
    }
    
    public boolean isRootWorkSpace() {
        return getCurrentWorkSpace() == getRootWorkSpace();
    }

    
    /**
     * @return the previousWorkSpace
     */
    public WorkSpace getPreviousWorkSpace() {
        return previousWorkSpace;
    }

    /**
     * @param previousWorkSpace the previousWorkSpace to set
     */
    private void setPreviousWorkSpace(WorkSpace previousWorkSpace) {
        this.previousWorkSpace = previousWorkSpace;
    }

    /**
     * @return the currentWorkSpace
     */
    public WorkSpace getCurrentWorkSpace() {
        if(currentWorkSpace == null){
            return getRootWorkSpace();
        }
        return currentWorkSpace;
    }
    
    public void setGenerateWorkSpaceClass(WorkSpace workspace) {
        assert(workspace!=null);
        getAllJavaClass()
                .forEach(jc -> jc.setGenerateSourceCode(false));
        getAllJavaClass()
                .stream()
                .filter(jc -> workspace.hasItem(jc))
                .forEach(jc -> jc.setGenerateSourceCode(true));
    }
        
    public Optional<WorkSpace> findGeneratedWorkSpace() {
        Set<WorkSpaceItem> selectedWorkSpaceItems = getAllJavaClass()
                .stream()
                .filter(c -> c.getGenerateSourceCode())
                .map(WorkSpaceItem::new)
                .collect(toSet());
        Optional<WorkSpace> optionalWorkSpace = getWorkSpaces()
                .stream()
                .filter(ws -> ws.getItems().equals(selectedWorkSpaceItems))
                .findAny();
        return optionalWorkSpace;
    }
    
    public List<JavaClass> findGeneratedClass() {
        return getAllJavaClass()
                .stream()
                .filter(c -> c.getGenerateSourceCode())
                .collect(toList());
    }

    /**
     * @param currentWorkSpace the currentWorkSpace to set
     */
    public void setCurrentWorkSpace(WorkSpace currentWorkSpace) {
        setPreviousWorkSpace(this.currentWorkSpace);
        this.currentWorkSpace = currentWorkSpace;
    }
    
    public void setCurrentWorkSpace(String currentWorkSpaceId) {
        Optional<WorkSpace> wsOptional = findWorkSpace(currentWorkSpaceId);
        if(wsOptional.isPresent()){
            this.currentWorkSpace = wsOptional.get();
        }
    }

    /**
     * @return the nextWorkSpace
     */
    public WorkSpace getNextWorkSpace() {
        if(nextWorkSpace == null){
            return getCurrentWorkSpace();
        }
        return nextWorkSpace;
    }

    /**
     * @param nextWorkSpace the nextWorkSpace to set
     */
    public void setNextWorkSpace(WorkSpace nextWorkSpace) {
        this.nextWorkSpace = nextWorkSpace;
    }

    /**
     * @return the workSpaces
     */
    public List<WorkSpace> getWorkSpaces() {
        if(workSpaces == null) {
            workSpaces = new ArrayList<>();
        }
        return workSpaces;
    }

    /**
     * @param workSpaces the workSpaces to set
     */
    public void setWorkSpaces(List<WorkSpace> workSpaces) {
        this.workSpaces = workSpaces;
    }
    
    public void addWorkSpace(WorkSpace workSpace) {
        getWorkSpaces().add(workSpace);
    }
    
    public void removeWorkSpace(WorkSpace workSpace) {
        getWorkSpaces().remove(workSpace);
    }
    
    public void removeAllWorkSpace() {
        getWorkSpaces().clear();
        getWorkSpaces().add(getRootWorkSpace());
        setCurrentWorkSpace((WorkSpace)null);
        setNextWorkSpace(getRootWorkSpace());
    }
    
    /**
     * Remove the selected workspace
     * @param workSpace
     * @return true if current workspace is also removed
     */
    public boolean removeAllWorkSpace(List<WorkSpace> workSpace) {
        getWorkSpaces().removeAll(workSpace);
        if (!getWorkSpaces().contains(getRootWorkSpace())) {
            getWorkSpaces().add(getRootWorkSpace());
        }
        boolean currentWorkSpaceDeleted = !getWorkSpaces().contains(getCurrentWorkSpace());
        if (currentWorkSpaceDeleted) {
            setCurrentWorkSpace((WorkSpace) null);
            setNextWorkSpace(getRootWorkSpace());
        }
        return currentWorkSpaceDeleted;
    }
    
    public Optional<WorkSpace> findWorkSpace(String workSpaceId) {
       return getWorkSpaces().stream().filter(ws -> ws.getId().equals(workSpaceId)).findAny();
    }

    /**
     * @return the jaxbSupport
     */
    public Boolean getJaxbSupport() {
        if(jaxbSupport == null){
            jaxbSupport = false;
        }
        return jaxbSupport;
    }

    /**
     * @param jaxbSupport the jaxbSupport to set
     */
    public void setJaxbSupport(Boolean jaxbSupport) {
        this.jaxbSupport = jaxbSupport;
    }
    
    /**
     * @return the jsonbSupport
     */
    public Boolean isJsonbPackageInfoExist() {
        return  jsonbPropertyNamingStrategy!=null
                || jsonbPropertyOrderStrategy!=null
                || jsonbNillable!=null
                || jsonbDateFormat!=null
                || jsonbNumberFormat!=null
                || (jsonbVisibility!=null && StringUtils.isNotBlank(jsonbVisibility.getName()));
    }

    /**
     * @return the jsonbPropertyNamingStrategy
     */
    public PropertyNamingStrategy getJsonbPropertyNamingStrategy() {
        return jsonbPropertyNamingStrategy;
    }

    /**
     * @param jsonbPropertyNamingStrategy the jsonbPropertyNamingStrategy to set
     */
    public void setJsonbPropertyNamingStrategy(PropertyNamingStrategy jsonbPropertyNamingStrategy) {
        this.jsonbPropertyNamingStrategy = jsonbPropertyNamingStrategy;
    }

    /**
     * @return the jsonbNillable
     */
    public Boolean getJsonbNillable() {
        if (jsonbNillable == null) {
            return true;
        }
        return jsonbNillable;
    }

    /**
     * @param jsonbNillable the jsonbNillable to set
     */
    public void setJsonbNillable(Boolean jsonbNillable) {
        this.jsonbNillable = jsonbNillable;
    }

    /**
     * @return the jsonbDateFormat
     */
    public JsonbDateFormat getJsonbDateFormat() {
        if(jsonbDateFormat==null){
            jsonbDateFormat = new JsonbDateFormat();
        }
        return jsonbDateFormat;
    }

    /**
     * @param jsonbDateFormat the jsonbDateFormat to set
     */
    public void setJsonbDateFormat(JsonbDateFormat jsonbDateFormat) {
        this.jsonbDateFormat = jsonbDateFormat;
    }

    /**
     * @return the jsonbNumberFormat
     */
    public JsonbNumberFormat getJsonbNumberFormat() {
        if(jsonbNumberFormat==null){
            jsonbNumberFormat = new JsonbNumberFormat();
        }
        return jsonbNumberFormat;
    }

    /**
     * @param jsonbNumberFormat the jsonbNumberFormat to set
     */
    public void setJsonbNumberFormat(JsonbNumberFormat jsonbNumberFormat) {
        this.jsonbNumberFormat = jsonbNumberFormat;
    }

    /**
     * @return the jsonbVisibility
     */
    public ReferenceClass getJsonbVisibility() {
        return jsonbVisibility;
    }

    /**
     * @param jsonbVisibility the jsonbVisibility to set
     */
    public void setJsonbVisibility(ReferenceClass jsonbVisibility) {
        this.jsonbVisibility = jsonbVisibility;
    }

    /**
     * @return the jsonbPropertyOrderStrategy
     */
    public PropertyOrderStrategy getJsonbPropertyOrderStrategy() {
        return jsonbPropertyOrderStrategy;
    }

    /**
     * @param jsonbPropertyOrderStrategy the jsonbPropertyOrderStrategy to set
     */
    public void setJsonbPropertyOrderStrategy(PropertyOrderStrategy jsonbPropertyOrderStrategy) {
        this.jsonbPropertyOrderStrategy = jsonbPropertyOrderStrategy;
    }

    /**
     * @return the jbTheme
     */
    public String getJBTheme() {
        return jbTheme;
    }

    /**
     * @param jbTheme the jbTheme to set
     */
    public void setJBTheme(String jbTheme) {
        this.jbTheme = jbTheme;
    }
    
}
